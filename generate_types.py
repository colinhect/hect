import glob
import os
import sys
import re
import xml.etree.ElementTree as ET

class ReflectType:
    def __init__(self, header, kind, name, values, properties):
        self.header = header
        self.kind = kind
        self.name = name
        self.values = values
        self.properties = properties
        
    def has_values(self):
        return not self.values is None and len(self.values) > 0
        
    def has_properties(self):
        return not self.properties is None and len(self.properties) > 0
        
setter_regex = re.compile(".*Setter for property \<emphasis\>([a-zA-Z0-9]+)\<\/emphasis\>.*", re.DOTALL)
getter_regex = re.compile(".*Getter for property \<emphasis\>([a-zA-Z0-9]+)\<\/emphasis\>.*", re.DOTALL)

if __name__ == "__main__":
    types = []
    
    for file_name in glob.glob(sys.argv[1]):
        with open(file_name, "r") as in_file:
            xml_string = in_file.read()
            root = ET.fromstring(xml_string)
            for compounddef in root.iter("compounddef"):
                name = compounddef.find("compoundname").text
                header = compounddef.find("location")
                if not header is None:
                    header = header.attrib["file"]
                if compounddef.attrib["kind"] == "class":
                    kind = "Kind::Class"
                elif compounddef.attrib["kind"] == "struct":
                    kind = "Kind::Structure"
                elif compounddef.attrib["kind"] == "namespace":
                    kind = "Kind::Enumeration"
                else:
                    break;
                    
                if kind == "Kind::Enumeration":
                    if name != "hect":
                        values = []
                        for sectiondef in compounddef.iter("sectiondef"):
                            for memberdef in compounddef.iter("memberdef"):
                                for enumvalue in memberdef.iter("enumvalue"):
                                    values.append((enumvalue.find("name").text, name + "::" + enumvalue.find("name").text))
                        name = name + "::Enum"
                        types.append(ReflectType(header, kind, name, values, None))
                else:
                    is_template = False
                    for templateparamlist in compounddef.iter("templateparamlist"):
                        is_template = True
                    if not is_template and compounddef.attrib["prot"] == "public":
                        properties = { }
                        if kind == "Kind::Class":
                            for memberdef in root.iter("memberdef"):
                                if memberdef.attrib["kind"] == "function":
                                    detaileddescription = memberdef.find("detaileddescription")
                                    if not detaileddescription is None:
                                        text = str(ET.tostring(detaileddescription, encoding='utf8', method='xml'))
                                        if not text is None:
                                            setter_match = setter_regex.match(text)
                                            getter_match = getter_regex.match(text)
                                            if setter_match:
                                                property_name = setter_match.group(1)
                                                if not property_name in properties:
                                                    properties[property_name] = { }
                                                properties[property_name]["setter"] = memberdef.find("name").text
                                            elif getter_match:
                                                property_name = getter_match.group(1)
                                                if not property_name in properties:
                                                    properties[property_name] = { }
                                                properties[property_name]["getter"] = memberdef.find("name").text
                                                if not memberdef.find("type").text is None:
                                                    type_text = memberdef.find("type").text
                                                else:
                                                    type_text = memberdef.find("type").find("ref").text
                                                properties[property_name]["type"] = type_text.replace("const ", "").replace("&", "").strip()
                        types.append(ReflectType(header, kind, name, None, properties))
                        
    types = [t for t in types if t.has_values() or t.has_properties()]
    for type in types:
        type.name = type.name.replace("hect::", "").strip()
    
    with open(sys.argv[2], "w") as code:
        code.write("// Generated by generate_types.py\n\n")
        code.write("#include \"Hect/Reflection/Type.h\"\n")
        for type in types:
            code.write("#include \"" + type.header + "\"\n")
        code.write("\n")
        code.write("using namespace hect;\n\n")
        code.write("class " + sys.argv[3] + "\n")
        code.write("{\n")
        code.write("public:\n")
        code.write("    " + sys.argv[3] + "()\n")
        code.write("    {\n")
        for type in types:
            code.write("        // " + type.name + "\n")
            code.write("        Type::addRegisterFunction([]()\n")
            code.write("        {\n")
            code.write("            Type::create<" + type.name + ">(" + type.kind  + ", \"" + type.name + "\");\n")
            if type.has_values() :
                for value in type.values:
                    code.write("            Enum::add<" + type.name + ">(\"" + value[0] + "\", " + value[1] + ");\n")
            code.write("        });\n")
        code.write("    }\n")
        code.write("} _" + sys.argv[3] + ";\n\n")
        
        primitives = [
            ("std::string", "jsonValue.asString()"),
            ("float", "(float)jsonValue.asDouble()"),
            ("double", "jsonValue.asDouble()"),
            ("uint8_t", "(uint8_t)jsonValue.asUnsigned()"),
            ("uint16_t", "(uint16_t)jsonValue.asUnsigned()"),
            ("uint32_t", "(uint32_t)jsonValue.asUnsigned()"),
            ("uint64_t", "(uint64_t)jsonValue.asInt()"),
            ("int8_t", "(int8_t)jsonValue.asInt()"),
            ("int16_t", "(int16_t)jsonValue.asInt()"),
            ("int32_t", "(int32_t)jsonValue.asInt()"),
            ("int64_t", "(int64_t)jsonValue.asInt()")
            ]
        for primitive in primitives:
            code.write("template <>\n")
            code.write("HECT_API void Object::fromJson<" + primitive[0] + ">(" + primitive[0]+ "& object, const JsonValue& jsonValue)\n")
            code.write("{\n")
            code.write("    object = " + primitive[1] + ";\n")
            code.write("}\n")
            code.write("\n")
            
        for type in types:
            code.write("template <>\n")
            code.write("HECT_API void Object::fromJson<" + type.name + ">(" + type.name + "&, const JsonValue&);\n")
            code.write("\n")
        
        for type in types:            
            if (not type.properties is None and len(type.properties) > 0) or (type.kind == "Kind::Enumeration"):
                code.write("template <>\n")
                code.write("HECT_API void Object::fromJson<" + type.name + ">(" + type.name + "& object, const JsonValue& jsonValue)\n")
                code.write("{\n")
                if not type.properties is None and len(type.properties) > 0:
                    for property_name in type.properties:
                        code.write("    if (!jsonValue[\"" + property_name + "\"].isNull())\n")
                        code.write("    {\n")
                        property = type.properties[property_name]
                        code.write("        " + property["type"] + " propertyValue;\n")
                        code.write("        Object::fromJson<" + property["type"] + ">(propertyValue, jsonValue[\"" + property_name + "\"]);\n")
                        code.write("        object." + property["setter"] + "(propertyValue);\n")
                        code.write("    }\n")
                elif type.kind == "Kind::Enumeration":
                    code.write("    object = Enum::fromString<" + type.name + ">(jsonValue.asString());\n")
            code.write("}\n")
            code.write("\n")
        