import glob
import os
import sys
import re
import xml.etree.ElementTree as ET

class Type:
    def __init__(self, header, namespace, name):
        self.header = header
        self.namespace = namespace
        self.name = name
        
class ClassType(Type):
    def __init__(self, header, namespace, name):
        Type.__init__(self, header, namespace, name)
        
class EnumType(Type):
    def __init__(self, header, namespace, name, values):
        Type.__init__(self, header, namespace, name)
        self.values = values
        

def process_xml(root):
    types = []
    for compounddef in root.iter("compounddef"):
        if "kind" in compounddef.attrib and compounddef.attrib["kind"] == "namespace":
            namespace = compounddef.find("compoundname").text
            for memberdef in compounddef.iter("memberdef"):
                kind = memberdef.attrib["kind"]
                if kind == "enum":
                
                    # Get the name of the type
                    name = memberdef.find("name").text
                
                    # Get the path to the header file
                    header = memberdef.find("location")
                    if not header is None:
                        header = header.attrib["file"]
                        
                    values = []
                    for enumvalue in memberdef.iter("enumvalue"):
                        values.append(enumvalue.find("name").text)
                            
                    types.append(EnumType(header, namespace, name, values))
        elif "kind" in compounddef.attrib and compounddef.attrib["kind"] == "class":
            if compounddef.attrib["prot"] == "public" and compounddef.find("templateparamlist") is None:
                name = compounddef.find("compoundname").text
                namespace = ""
                if "::" in name:
                    namespace = name.split("::")[0]
                    name = name.split("::", 1)[1]
                # Get the path to the header file
                header = compounddef.find("location")
                if not header is None:
                    header = header.attrib["file"]
                types.append(ClassType(header, namespace, name))
    return types
        
if __name__ == "__main__":
    types = []

    input_dir = sys.argv[1]
    output_dir = sys.argv[2]
    types_name = sys.argv[3]
    
    # Process each file
    for file_name in glob.glob(input_dir):
        if os.path.isfile(file_name):
            with open(file_name, "r") as in_file:
                root = ET.fromstring(in_file.read())
                types.extend(process_xml(root))
        
    source_file_name = os.path.join(output_dir, types_name + ".cpp")    
    with open(source_file_name, "w") as f:
        f.write("// Generated by reflect.py\n")
        f.write("#include \"Hect/Reflection/Type.h\"\n\n")
        for type in types:
            header_path = os.path.relpath(type.header, output_dir)
            f.write("#include \"" + header_path + "\"\n")
        f.write("\n")            
        f.write("class " + types_name + " { };\n")
        f.write("using namespace hect;\n")            
        f.write("template <>\n")
        f.write("void Type::registerTypes<" + types_name + ">()\n")
        f.write("{\n")
        for type in types:
            if isinstance(type, ClassType):
                f.write("    {\n")
                f.write("        Type& type = Type::create<" + type.name + ">(Kind_Class, \"" + type.name + "\");\n")
                f.write("        type;\n")
                f.write("    }\n")
            elif isinstance(type, EnumType):
                f.write("    {\n")
                f.write("        Type& type = Type::create<" + type.name + ">(Kind_Enum, \"" + type.name + "\");\n")
                f.write("        EnumMetaData& metaData = type.enumMetaData();\n")
                for value in type.values:
                    str_value = value
                    if "_" in str_value:
                        str_value = str_value.split("_", 1)[1]
                    f.write("        metaData.addValue(" + value + ", \""  + str_value + "\");\n");
                f.write("    }\n")
        f.write("}\n")
            
        